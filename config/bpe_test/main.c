#define PRH_STRIP_PREFIX
#include "prelude.h"

void bpe_enc(const char *s);

int main(int argc, char *argv[])
{
    bpe_enc(NULL);
    bpe_enc("");
    bpe_enc("a");
    bpe_enc("aa");
    bpe_enc("ab");
    bpe_enc("aaa");
    bpe_enc("aaaa");
    bpe_enc("aaaaa");
    bpe_enc("aaaaaaa");
    bpe_enc("aaaaaaaaa");
    bpe_enc("abab");
    bpe_enc("ababab");
    bpe_enc("abababab");
    bpe_enc("ababababab");
    bpe_enc("TABLE OF CONTENTS"
    "    Table of Contents"
    "    Compile-time options"
    "    License"
    "    Documentation"
    "    Notes"
    "    Notes - Dynamic arrays"
    "    Notes - Hash maps"
    "    Credits"
    "  COMPILE-TIME OPTIONS"
    "    #define STBDS_NO_SHORT_NAMES"
    "       This flag needs to be set globally."
    "       By default stb_ds exposes shorter function names that are not qualified"
    "       with the stbds_ prefix. If these names conflict with the names in your"
    "       code, define this flag."
    "    #define STBDS_SIPHASH_2_4"
    "       This flag only needs to be set in the file containing #define STB_DS_IMPLEMENTATION."
    "       By default stb_ds.h hashes using a weaker variant of SipHash and a custom hash for"
    "       4- and 8-byte keys. On 64-bit platforms, you can define the above flag to force"
    "       stb_ds.h to use specification-compliant SipHash-2-4 for all keys. Doing so makes"
    "       hash table insertion about 20% slower on 4- and 8-byte keys, 5% slower on"
    "       64-byte keys, and 10% slower on 256-byte keys on my test computer."
    "    #define STBDS_REALLOC(context,ptr,size) better_realloc"
    "    #define STBDS_FREE(context,ptr)         better_free"
    "       These defines only need to be set in the file containing #define STB_DS_IMPLEMENTATION."
    "       By default stb_ds uses stdlib realloc() and free() for memory management. You can"
    "       substitute your own functions instead by defining these symbols. You must either"
    "       define both, or neither. Note that at the moment, 'context' will always be NULL."
    "       @TODO add an array/hash initialization function that takes a memory context pointer."
    "    #define STBDS_UNIT_TESTS"
    "       Defines a function stbds_unit_tests() that checks the functioning of the data structures."
    "    Note that on older versions of gcc (e.g. 5.x.x) you may need to build with '-std=c++0x'"
    "       (or equivalentally '-std=c++11') when using anonymous structures as seen on the web"
    "       page or in STBDS_UNIT_TESTS."
    "  LICENSE"
    "    Placed in the public domain and also MIT licensed."
    "    See end of file for detailed license information."
    "  DOCUMENTATION"
    "    Dynamic Arrays"
    "      Non-function interface:"
    "        Declare an empty dynamic array of type T"
    "          T* foo = NULL;"
    "        Access the i'th item of a dynamic array 'foo' of type T, T* foo:"
    "          foo[i]"
    "      Functions (actually macros)"
    "        arrfree:"
    "          void arrfree(T*);"
    "            Frees the array."
    "        arrlen:"
    "          ptrdiff_t arrlen(T*);"
    "            Returns the number of elements in the array."
    "        arrlenu:"
    "          size_t arrlenu(T*);"
    "            Returns the number of elements in the array as an unsigned type."
    "        arrpop:"
    "          T arrpop(T* a)"
    "            Removes the final element of the array and returns it."
    "        arrput:"
    "          T arrput(T* a, T b);"
    "            Appends the item b to the end of array a. Returns b."
    "        arrins:"
    "          T arrins(T* a, int p, T b);"
    "            Inserts the item b into the middle of array a, into a[p],"
    "            moving the rest of the array over. Returns b."
    "        arrinsn:"
    "          void arrinsn(T* a, int p, int n);"
    "            Inserts n uninitialized items into array a starting at a[p],"
    "            moving the rest of the array over."
    "        arraddnptr:"
    "          T* arraddnptr(T* a, int n)"
    "            Appends n uninitialized items onto array at the end."
    "            Returns a pointer to the first uninitialized item added."
    "        arraddnindex:"
    "          size_t arraddnindex(T* a, int n)"
    "            Appends n uninitialized items onto array at the end."
    "            Returns the index of the first uninitialized item added."
    "        arrdel:"
    "          void arrdel(T* a, int p);"
    "            Deletes the element at a[p], moving the rest of the array over."
    "        arrdeln:"
    "          void arrdeln(T* a, int p, int n);"
    "            Deletes n elements starting at a[p], moving the rest of the array over."
    "        arrdelswap:"
    "          void arrdelswap(T* a, int p);"
    "            Deletes the element at a[p], replacing it with the element from"
    "            the end of the array. O(1) performance."
    "        arrsetlen:"
    "          void arrsetlen(T* a, int n);"
    "            Changes the length of the array to n. Allocates uninitialized"
    "            slots at the end if necessary."
    "        arrsetcap:"
    "          size_t arrsetcap(T* a, int n);"
    "            Sets the length of allocated storage to at least n. It will not"
    "            change the length of the array."
    "        arrcap:"
    "          size_t arrcap(T* a);"
    "            Returns the number of total elements the array can contain without"
    "            needing to be reallocated."
    "    Hash maps & String hash maps"
    "      Given T is a structure type: struct { TK key; TV value; }. Note that some"
    "      functions do not require TV value and can have other fields. For string"
    "      hash maps, TK must be 'char *'."
    "      Special interface:"
    "        stbds_rand_seed:"
    "          void stbds_rand_seed(size_t seed);"
    "            For security against adversarially chosen data, you should seed the"
    "            library with a strong random number. Or at least seed it with time()."
    "        stbds_hash_string:"
    "          size_t stbds_hash_string(char *str, size_t seed);"
    "            Returns a hash value for a string."
    "        stbds_hash_bytes:"
    "          size_t stbds_hash_bytes(void *p, size_t len, size_t seed);"
    "            These functions hash an arbitrary number of bytes. The function"
    "            uses a custom hash for 4- and 8-byte data, and a weakened version"
    "            of SipHash for everything else. On 64-bit platforms you can get"
    "            specification-compliant SipHash-2-4 on all data by defining"
    "            STBDS_SIPHASH_2_4, at a significant cost in speed."
    "      Non-function interface:"
    "        Declare an empty hash map of type T"
    "          T* foo = NULL;"
    "        Access the i'th entry in a hash table T* foo:"
    "          foo[i]"
    "      Function interface (actually macros):"
    "        hmfree"
    "        shfree"
    "          void hmfree(T*);"
    "          void shfree(T*);"
    "            Frees the hashmap and sets the pointer to NULL."
    "        hmlen"
    "        shlen"
    "          ptrdiff_t hmlen(T*)"
    "          ptrdiff_t shlen(T*)"
    "            Returns the number of elements in the hashmap."
    "        hmlenu"
    "        shlenu"
    "          size_t hmlenu(T*)"
    "          size_t shlenu(T*)"
    "            Returns the number of elements in the hashmap."
    "        hmgeti"
    "        shgeti"
    "        hmgeti_ts"
    "          ptrdiff_t hmgeti(T*, TK key)"
    "          ptrdiff_t shgeti(T*, char* key)"
    "          ptrdiff_t hmgeti_ts(T*, TK key, ptrdiff_t tempvar)"
    "            Returns the index in the hashmap which has the key 'key', or -1"
    "            if the key is not present."
    "        hmget"
    "        hmget_ts"
    "        shget"
    "          TV hmget(T*, TK key)"
    "          TV shget(T*, char* key)"
    "          TV hmget_ts(T*, TK key, ptrdiff_t tempvar)"
    "            Returns the value corresponding to 'key' in the hashmap."
    "            The structure must have a 'value' field"
    "        hmgets"
    "        shgets"
    "          T hmgets(T*, TK key)"
    "          T shgets(T*, char* key)"
    "            Returns the structure corresponding to 'key' in the hashmap."
    "        hmgetp"
    "        shgetp"
    "        hmgetp_ts"
    "        hmgetp_null"
    "        shgetp_null"
    "          T* hmgetp(T*, TK key)"
    "          T* shgetp(T*, char* key)"
    "          T* hmgetp_ts(T*, TK key, ptrdiff_t tempvar)"
    "          T* hmgetp_null(T*, TK key)"
    "          T* shgetp_null(T*, char *key)"
    "            Returns a pointer to the structure corresponding to 'key' in"
    "            the hashmap. Functions ending in _null return NULL if the key"
    "            is not present in the hashmap; the others return a pointer to a"
    "            structure holding the default value (but not the searched-for key)."
    "        hmdefault"
    "        shdefault"
    "          TV hmdefault(T*, TV value)"
    "          TV shdefault(T*, TV value)"
    "            Sets the default value for the hashmap, the value which will be"
    "            returned by hmget/shget if the key is not present."
    "        hmdefaults"
    "        shdefaults"
    "          TV hmdefaults(T*, T item)"
    "          TV shdefaults(T*, T item)"
    "            Sets the default struct for the hashmap, the contents which will be"
    "            returned by hmgets/shgets if the key is not present."
    "        hmput"
    "        shput"
    "          TV hmput(T*, TK key, TV value)"
    "          TV shput(T*, char* key, TV value)"
    "            Inserts a <key,value> pair into the hashmap. If the key is already"
    "            present in the hashmap, updates its value."
    "        hmputs"
    "        shputs"
    "          T hmputs(T*, T item)"
    "          T shputs(T*, T item)"
    "            Inserts a struct with T.key into the hashmap. If the struct is already"
    "            present in the hashmap, updates it."
    "        hmdel"
    "        shdel"
    "          int hmdel(T*, TK key)"
    "          int shdel(T*, char* key)"
    "            If 'key' is in the hashmap, deletes its entry and returns 1."
    "            Otherwise returns 0."
    "      Function interface (actually macros) for strings only:"
    "        sh_new_strdup"
    "          void sh_new_strdup(T*);"
    "            Overwrites the existing pointer with a newly allocated"
    "            string hashmap which will automatically allocate and free"
    "            each string key using realloc/free"
    "        sh_new_arena"
    "          void sh_new_arena(T*);"
    "            Overwrites the existing pointer with a newly allocated"
    "            string hashmap which will automatically allocate each string"
    "            key to a string arena. Every string key ever used by this"
    "            hash table remains in the arena until the arena is freed."
    "            Additionally, any key which is deleted and reinserted will"
    "            be allocated multiple times in the string arena.");
    return 0;
}
