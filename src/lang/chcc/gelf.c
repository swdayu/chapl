// ELF - Executable and Linking Format
#define __CURR_FILE__ STRID_CHCC_GELF
#include "internal/decl.h"
#include "chcc/gelf.h"

// LINUX 进程典型内存布局：
//  0x0000_0000 [   ...            ] 虚拟内存开始，大概 128MB 空间也可用于栈
//              [   ...            ]
//  0x0804_8000 [   Text           ] 代码区 -----------------> ELF_BASE -
//              [   ...            ]                                    |
//              [   Data           ] 初始化数据区                        |
//              [   ...            ]                                    |
//              [   BSS            ] 未初始化数据区                      | data_offset
//              [   ...            ]                                    |
//              [   Heap           ] 堆                                 |
//              [   ...            ]                                    |
//              [   ...            ] -----------------------> data -----'
//              [   ...            ]             | ELFSTART_SIZE
//              [   ...            ]             | ...
//              [   ...            ]             | <-------------- glo
//              [   ...            ]
//              [   ...            ]
//              [   Stack elem N   ] 栈顶
//              [   Stack elem 2   ]
//              [   Stack elem 1   ] 用户栈内容
//              [   envrion        ] 环境变量  （进程初始化栈内容）
//              [   argv           ] 命令行参数（进程初始化栈内容）
//  0x8000_0000 [   Dynamic        ] 动态段，用于加载共享对象分区
//              [   ...            ]
//              [   ...            ]
//  0xC000_0000 [   Kernel         ] 系统内核
//              [   ...            ]
//              [   ...            ]
//  0xFFFF_FFFF [   ...            ]
//
// 操作系统设施，例如 mmap(KE_OS)，允许进程用两种方式建立地址映射，一种是程序可以让系统
// 选择一个地址，另一种方式程序可以强制系统使用程序提供的地址。但第二种可能导致应用程序
// 移植问题，因为要求的地址可能不总是可用。
//
// 进程的地址空间通常有三个段区域，这些区域的大小可能在不同的执行中发生变化：
// 栈大小可以通过系统调用 setrlimit(BA_OS) 来设置；数据段通常用于存储程序的静态和全局
// 变量，其大小可以通过动态内存分配函数 malloc(BA_OS) 改变；动态段区域用于映射文件、共
// 享库、或共享其他进程的内存到当前进程的地址空间，其大小和位置可以通过 mmap(KE_OS) 系
// 统调用来控制。一个区域的变化可能会影响另一个区域可用的虚拟地址。因此，在一个进程执行
// 中可用的地址可能在下一个执行中就不可用了。一个使用 mmap(KE_OS) 请求特定地址映射的程
// 序可能在某些环境中看似工作正常，而在其他环境中失败。因此，希望在其地址空间建立映射的
// 程序应该让系统选择地址。尽管有关于请求特定地址的警告，但这种功能既实用又可以在受控的
// 方式下使用。例如，一个多进程应用程序可能将几个文件映射到每个进程的地址空间，并在文件
// 数据之间建立相对指针。这可以通过让每个进程在系统选择的地址上请求一定量的内存来实现。
// 在每个进程接收到系统分配的私有地址后，它会将所需的文件映射到内存中，在原始区域的特定
// 地址内。这些映射集合可能在每个进程中的地址都不同，但它们的相对位置是固定的。如果没有
// 请求特定地址的能力，应用程序就无法构建共享数据结构，因为每个进程中文件的相对位置将不
// 可预测。
//
// 当系统创建或扩展进程映像时，它会在逻辑上将文件的段复制到虚拟内存段。系统何时以及是否
// 物理读取文件取决于程序的执行行为、系统负载等。除非在执行过程中引用了逻辑页，否则进程
// 不需要物理页，而且进程通常会留下很多未引用的页。因此，延迟物理读取通常可以避免这种读
// 取，提高系统性能。为了在实践中获得这种效率，可执行文件和共享对象文件必须具有文件偏移
// 量和虚拟地址在页大小模下同余的段映像。对于 Intel386 架构的段，虚拟地址和文件偏移量在
// 模 4KB（0x1000）或更大的 2 的幂下是同余的。因为 4KB 是最大页大小，所以无论物理页大
// 小如何，文件都适合分页。
// 尽管示例中的文件偏移量和虚拟地址在模 4KB 下对于代码和数据都是相等的，但有四个文件页可
// 能包含不纯的代码或数据（这取决于页大小和文件系统块大小）：
// 1. 第一个代码页包含 ELF 头、程序头部表和其他信息
// 2. 最后一个代码页包含数据开始的副本
// 3. 第一个数据页有代码结束的副本
// 4. 最后一个数据页可能包含对运行进程不相关的文件信息
// 在逻辑上，系统强制应用内存权限，就好像每个段都是完整且独立的；段的地址会被调整以确保
// 地址空间中每个逻辑页具有单一的一组权限。在上面的例子中，包含代码末尾和数据开头的文件
// 区域将被映射两次：在一个虚拟地址用于代码，在不同的虚拟地址用于数据。数据段的末尾需要
// 对未初始化数据进行特殊处理，系统将其定义为以零值开始。因此，如果文件的最后一个数据页
// 包含不在逻辑内存页中的信息，那么多余的数据必须设置为零，而不是可执行文件的未知内容。
// 其他三个页面中的杂质内容在逻辑上不属于进程映像的一部分，系统是否清除它们是未指定的。
// 可执行文件和共享对象在段加载方面有一个不同之处。可执行文件段通常包含绝对代码。为了让
// 进程正确执行，段必须位于用于构建可执行文件的虚拟地址上。因此，系统将 vaddr 值不变地
// 用作虚拟地址。另一方面，共享对象段通常包含位置无关代码。这允许段的虚拟地址在不同进程
// 中可以不同，而且不会导致无效执行行为。尽管系统为个别进程选择虚拟地址，但它保持段的相
// 对位置。因为位置无关代码使用段之间的相对寻址，所以内存中的虚拟地址差异必须与文件中的
// 虚拟地址差异相匹配。
//
// 可执行文件：
//  文件偏移         文件内容              虚拟地址
//  0x0000_0000 [   ELF header          ] 0x0804_8000
//              [   Program header table]
//              [   Other information   ]
//  0x0000_0100 [   Text segment        ] 0x0804_8100
//              [   ...                 ]
//              [   0x0002_be00 bytes   ]
//  0x0002_bf00 [   Data segment        ] 0x0807_4f00
//              [   ...                 ]
//              [   0x0000_4e00 bytes   ]
//  0x0003_0d00 [   Other information   ] 0x0807_9d00
//              [   ...                 ]
//              [   0x0000_1024 bytes   ]
//  0x0003_1d24 [   Page padding        ] 0x0807_ad24
//              [   0x0000_02dc bytes   ]
//  0x0003_2000 |                       | 0x0807_b000
//
//  程序头部字段     代码段           数据段
//      type        PT_LOAD         PT_LOAD
//      offset      0x0000_0100     0x0002_bf00
//      vaddr       0x0804_8100     0x0807_4f00
//      paddr       0x0000_0000     0x0000_0000
//      filesz      0x0002_be00     0x0000_4e00
//      memsz       0x0002_be00     0x0000_5e24
//      flags       PF_R|X          PF_R|W|X
//      align       0x1000          0x1000
//
// 假设 4KB（0x1000）页面，以下是该程序的内存映像：
//  进程映像虚拟地址        内容           内存段
//  0x0804_8000 [   Header padding      ]           0x0000_0000
//              [   0x0000_0100 bytes   ]
//  0x0804_8100 [   Text segment        ]           0x0000_0100
//              [   ...                 ] 代码段
//              [   0x0002_be00 bytes   ]
//  0x0807_3f00 [   Data padding        ]           0x0002_af00
//              [   0x0000_0100 bytes   ]
//
//  0x0807_4000 [   Text padding        ]           0x0002_b000
//              [   0x0000_0f00 bytes   ]
//  0x0807_4f00 [   Data segment        ]           0x0002_bf00
//              [   ...                 ] 数据段
//              [   0x0000_4e00 bytes   ]
//  0x0807_9d00 [   Unintialized data   ]           0x0003_0d00
//              [   0x0000_1024 zeros   ]
//  0x0807_ad24 [   Page padding        ]           0x0003_1d24
//              [   0x0000_02dc zeros   ]
//  0x0807_b000 |                       |           0x0003_2000
//
// 如果是共享对象文件，多个进程可能的共享对象虚拟地址分配（动态段从 0x8000_0000 开始）：
//              程序基地址        代码段           数据段
//  文件偏移    0x0000_0000     0x0000_0100     0x0002_af00
//  第一进程    0x8000_0000     0x8000_0100     0x8002_af00
//  第二进程    0x8008_1000     0x8008_1100     0x800a_bf00
//  第三进程    0x900c_0000     0x900c_0100     0x900e_af00
//  第四进程    0x900c_6000     0x900c_6100     0x900f_0f00
//
// Intel 64位模式下，规范形式地址根据最高有效位是1还是0，其最高位到最高有效位被设置全1
// 或全0。Intel 64 架构定义了一个64位的线性地址，但具体实现可能支持较少位数，首个支持
// Intel 64 架构的处理上实现支持48位线性地址，这意味着地址根据47位的值其63位到47位是全
// 1或全0。如果线性内存地址不处于规范形式，实现应该生成一个异常。Intel x86 和 x64 系统
// 使用的页面大小为 4KB，或启用大内存页面模式扩大到 4MB 大小。
//
// 尽管 AMD64 架构使用 64 位指针，但实现只要求处理 48 位地址。因此，符合规范的进程只能
// 使用从 0x0000_0000_0000_0000 到 0x0000_7fff_ffff_ffff 的地址范围。0x0000_ffff_ffff_ffff
// 是一个非规范地址，不能被使用。进程通常开始时有三个逻辑段，通常称为代码（text）、数据
//（data）和栈（stack）。另外使用共享库会动态添加其他段，一个进程也可能动态创建段。系统
// 允许使用任何介于 4KB 到 64KB 之间的 2 的幂次方页大小，包括 4KB 和 64KB。AMD64 Linux
// 典型虚拟内存布局：
//  0x0000_0000_0000_0000   [   Unmapped        ] 未映射区域
//                          [   ...             ]
//  0x0000_0000_0040_0000   [   Text            ] 代码段
//                          [   ...             ]
//                          [   Data            ] 初始化数据段
//                          [   ...             ]
//                          [   BSS             ] 未初始化数据段
//                          [   ...             ]
//                          [   Heap            ] 堆
//                          [   ...             ]
//                          [   ...             ]
//                          [   ...             ]
//                          [   Stack elem N    ] 栈顶
//                          [   Stack elem 2    ]
//                          [   Stack elem 1    ] 用户栈内容
//                          [   envrion         ] 环境变量  （进程初始化栈内容）
//                          [   argv            ] 命令行参数（进程初始化栈内容）
//  0x0000_0800_0000_0000   [   Dynamic         ] 动态段，用于加载共享对象分区
//                          [   ...             ]
//                          [   ...             ]
//                          [   Kernel          ] 系统内核
//                          [   ...             ]
//                          [   ...             ]
//  0xFFFF_FFFF_FFFF_FFFF   [   ...             ]
//
// 程序加载是将文件段映射到虚拟内存段的过程。为了有效地映射可执行文件和共享对象文件，文
// 件偏移量必须与虚拟地址在页大小模下同余。为了节省空间，包含代码段最后一页的文件页也可
// 能包含数据段的第一页。数据段最后一页可能包含运行进程不相关的文件信息。在逻辑上，系统
// 按照完整独立的每个段来应用内存权限，段的地址会被调整以确保地址空间中每个逻辑页具有单
// 一的一组权限。在上面的例子中，包含文本末尾和数据开头的文件区域将被映射两次：在一个虚
// 拟地址用于文本，在不同的虚拟地址用于数据。数据段的末尾需要对未初始化数据进行特殊处理，
// 系统将其定义为零值。因此，如果数据段最后一页包含不在逻辑内存页中的信息，那么这些多余
// 的数据必须被设置为零，而不是可执行文件中的未知内容。
// 可执行文件和共享对象在段加载方面有一个不同之处。可执行文件段通常包含绝对代码。为了使
// 进程正确执行，段必须位于用于构建可执行文件的虚拟地址上。因此，系统不改变地使用 vaddr
// 值作为虚拟地址。另一方面，共享对象段通常包含位置无关代码。这允许段的虚拟地址在不同进
// 程中是变化的，而且不会导致无效执行行为。尽管系统为个别进程选择虚拟地址，但它保持段的
// 相对位置。因为位置无关代码使用段之间的相对寻址，所以内存中的虚拟地址之间的差异必须与
// 文件中的虚拟地址之间的差异相匹配。
//
// 地址重定位涉及两个分区，一个分区是该地址所在分区，也即该分区中的这个地址内容需要重定
// 位为实际的地址，一般这个分区是代码分区，第二个分区是符号分区，也即该地址对应的符号的
// 分区，需要重定位的就是这个符号的实际地址。重定位需要知道：
// 1. 符号在符号分区的索引
// 2. 代码分区的文件偏移
// 3. 地址所在位置的分区偏移
// 4. 地址是一个绝对地址还是一个相对于程序计数器的相对地址，即重定位的类型
//
// 程序加载会将文件分段映射到内存分段，文件分段的地址使用的是文件偏移地址，内存分段的地址
// 使用的是内存虚拟地址，内存虚拟地址会以内存分页为单位最终映射到实际的物理地址。内存分段
// 会对齐到内存分页的整数倍位置，这会导致内存分段之前和之后可能有空白填补空间，例如代码
// 分段之后的数据分区，其开始部分可能是填补的空白空间。
//
// 目标文件和共享文件的基地址为0，各分区的偏移地址相当于就是该分区的虚拟地址，目标文件和
// 共享文件的文件结构如下：
//  0x0000_0000 [   ELF Header      ] 文件头部，只读属于代码区
//              [   ...             ]
//              [   Section Header  ] 分区头部，只读属于代码区
//              [   ...             ]
//              [   .text           ] 代码区，只读，可执行
//              [   ...             ]
//              [   .rodata         ] 只读数据
//              [   ...             ]
//              [   .strtab         ] 只读字符串
//              [   ...             ]
//              [   .symtab         ] 字符串表
//              [   ...             ]
//              [   .data           ] 数据区，可写，可执行
//              [   ...             ]
//              [   .bss            ] 未初始化数据区
//              [   ...             ]

uint32 elf_hash(const byte* sym_name)
{
    uint32 h = 0, g;
    while (*sym_name) {
        h = (h << 4) + *sym_name++;
        g = (h & 0xf0000000);
        if (g) {
            h ^= g >> 24;
        }
        h &= ~g;
    }
    return h;
}
